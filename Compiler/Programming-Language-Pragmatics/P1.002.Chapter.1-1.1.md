# 1.1 The Art of Language Design

Today there are thousands of high-level programming languages, and new ones continue to emerge. Why are there so many? There are several possible answers:

如今，有成千上万种高级编程语言，并且新的语言不断涌现。为什么有那么多？有几种可能的答案：

* *Evolution*. Computer science is a young discipline; we're constantly finding better ways to do things. The late 1960s and early 1970s saw a revolution in “structured programming,” in which the goto-based control flow of languages like Fortran, Cobol, and Basic3 gave way to while loops, case (switch) statements, and similar higher-level constructs. In the late 1980s the nested block structure of languages like Algol, Pascal, and Ada began to give way to the object-oriented structure of languages like Smalltalk, C++, Eiffel, and—a decade later—Java and C#. More recently, scripting languages like Python and Ruby have begun to displace more traditional compiled languages, at least for rapid development.<br> 进化。计算机科学是一门年轻的学科。我们一直在寻找更好的做事方式。 1960年代末和1970年代初见证了“结构化编程”的一场革命，在这种革命中，基于Forto，Cobol和Basic3等语言的基于goto的控制流被while循环，case（switch）语句和类似的高层结构所取代。 。在1980年代后期，诸如Algol，Pascal和Ada之类的语言的嵌套块结构开始让位于诸如Smalltalk，C ++，Eiffel以及十年后的Java和C＃之类的面向对象的语言结构。最近，至少为了快速开发，诸如Python和Ruby之类的脚本语言已开始取代更传统的编译语言。
* *Special Purposes*. Some languages were designed for a specific problem domain. The various Lisp dialects are good for manipulating symbolic data and complex data structures. Icon and Awk are good for manipulating character strings. C is good for low-level systems programming. Prolog is good for reasoning about logical relationships among data. Each of these languages can be used successfully for a wider range of tasks, but the emphasis is clearly on the specialty. <br> 特殊用途。一些语言是为特定问题领域设计的。各种Lisp方言都非常适合处理符号数据和复杂的数据结构。 Icon和Awk非常适合处理字符串。 C适用于底层系统编程。 Prolog有助于推理数据之间的逻辑关系。这些语言中的每一种都可以成功地用于更广泛的任务，但是重点显然是专业。
* *Personal Preference*. Different people like different things. Much of the parochialism of programming is simply a matter of taste. Some people love the terseness of C; some hate it. Some people find it natural to think recursively; others prefer iteration. Some people like to work with pointers; others prefer the implicit dereferencing of Lisp, Java, and ML. The strength and variety of personal preference make it unlikely that anyone will ever develop a universally acceptable programming language. <br> 个人喜好。不同的人喜欢不同的事物。编程中的许多偏执主义只是一个品味问题。有些人喜欢C的简洁性。有些讨厌。有些人发现递归思考很自然。其他人则喜欢迭代。有些人喜欢使用指针。其他人则喜欢Lisp，Java和ML的隐式取消引用。个人喜好的强项和多样性使任何人都不可能开发出一种普遍接受的编程语言。

Of course, some languages are more successful than others. Of the many that have been designed, only a few dozen are widely used. What makes a language successful? Again there are several answers:

当然，某些语言比其他语言更成功。在已设计的许多设计中，只有几十个得到了广泛使用。是什么使语言成功？再次有几个答案：

* Expressive Power. One commonly hears arguments that one language is more “powerful” than another, though in a formal mathematical sense they are all Turing complete—each can be used, if awkwardly, to implement arbitrary algorithms. Still, language features clearly have a huge impact on the programmer's ability to write clear, concise, and maintainable code, especially for very large systems. There is no comparison, for example, between early versions of Basic on the one hand, and C++ on the other. The factors that contribute to expressive power—abstraction facilities in particular—are a major focus of this book. <br> 表现力。人们通常会听到一种说法，即一种语言比另一种语言更“强大”，尽管从形式上的数学意义上讲，它们都是图灵完整的—如果笨拙地可以使用每种语言来实现任意算法。尽管如此，语言功能显然仍对程序员编写清晰，简洁和可维护的代码的能力产生巨大影响，特别是对于大型系统而言。例如，一方面没有早期版本的Basic，另一方面有C ++，这之间没有可比性。本书主要关注有助于表达能力的因素，尤其是抽象设施。
* Ease of Use for the Novice. While it is easy to pick on Basic, one cannot deny its success. Part of that success was due to its very low “learning curve.” Pascal was taught for many years in introductory programming language courses because, at least in comparison to other “serious” languages, it was compact and easy to learn. Shortly after the turn of the century, Java came to play a similar role; though substantially more complex than Pascal, it is simpler than, say, C++. In a renewed quest for simplicity, some introductory courses in recent years have turned to scripting languages like Python. <br> 易于使用，适合新手。虽然很容易选择Basic，但不能否认它的成功。取得成功的部分原因是其“学习曲线”非常低。 Pascal在入门级编程语言课程中教了很多年，因为至少与其他“严肃”语言相比，它紧凑且易于学习。世纪之交后不久，Java发挥了类似的作用。尽管比Pascal复杂得多，但比说C ++更简单。为了追求简单性，近年来，一些入门课程转向了像Python这样的脚本语言。
* Ease of Implementation. In addition to its low learning curve, Basic was successful because it could be implemented easily on tiny machines, with limited resources. Forth had a small but dedicated following for similar reasons. Arguably the single most important factor in the success of Pascal was that its designer, Niklaus Wirth, developed a simple, portable implementation of the language, and shipped it free to universities all over the world (see Example 1.15).<sup>4</sup> The Java and Python designers took similar steps to make their language available for free to almost anyone who wants it.
* 易于实现。除了学习曲线低之外，Basic之所以成功，是因为它可以在资源有限的微型机器上轻松实现。出于类似的原因，Forth的追随者很少，但也很专心。可以说，Pascal成功的最重要因素是其设计师Niklaus Wirth开发了一种简单，可移植的语言实现，并将其免费提供给世界各地的大学（请参见示例1.15）。<sup>4</sup>Java和Python设计师采取了类似的步骤，使几乎所有需要它的人都可以免费使用他们的语言。
* Standardization. Almost every widely used language has an official international standard or (in the case of several scripting languages) a single canonical implementation; and in the latter case the canonical implementation is almost invariably written in a language that has a standard. Standardization—of both the language and a broad set of libraries—is the only truly effective way to ensure the portability of code across platforms. The relatively impoverished standard for Pascal, which was missing several features considered essential by many programmers (separate compilation, strings, static initialization, random-access I/O), was at least partially responsible for the language's drop from favor in the 1980s. Many of these features were implemented in different ways by different vendors.<br> 标准化。几乎每种广泛使用的语言都有一个官方的国际标准，或者（对于几种脚本语言而言）是一个规范的实现。在后一种情况下，规范的实现几乎总是以一种具有标准的语言编写的。语言和各种库的标准化是确保代码跨平台可移植性的唯一真正有效的方法。 Pascal的相对贫困的标准缺少许多程序员认为必不可少的若干功能（单独的编译，字符串，静态初始化，随机访问I / O），至少部分原因是该语言在1980年代不受欢迎的原因。其中许多功能是由不同的供应商以不同的方式实现的。
* Open Source. Most programming languages today have at least one open-source compiler or interpreter, but some languages—C in particular—are much more closely associated than others with freely distributed, peer-reviewed, community-supported computing. C was originally developed in the early 1970s by Dennis Ritchie and Ken Thompson at Bell Labs,5 in conjunction with the design of the original Unix operating system. Over the years Unix evolved into the world's most portable operating system—the OS of choice for academic computer science—and C was closely associated with it. With the standardization of C, the language became available on an enormous variety of additional platforms. Linux, the leading open-source operating system, is written in C. As of June 2015, C and its descendants account for well over half of a variety oflanguage-related on-line content, including web page references, book sales, employment listings, and open-source repository updates. <br> 开源。如今，大多数编程语言都至少具有一种开源编译器或解释器，但是某些语言（尤其是C语言）与自由分发，经过同行评审且受社区支持的计算相比，其关联性要高得多。 C语言最初是由Bell Labs的Dennis Ritchie和Ken Thompson 5在1970年代初期与原始Unix操作系统的设计一起开发的。多年来，Unix演变为世界上最可移植的操作系统（学术计算机科学的首选操作系统），而C与之紧密相关。随着C的标准化，该语言可在多种其他平台上使用。领先的开源操作系统Linux用C编写。截至2015年6月，C及其后代在各种语言相关的在线内容（包括网页参考，书籍销售，就业清单）中占了一半以上。 ，以及开放源代码存储库更新。
* Excellent Compilers. Fortran owes much of its success to extremely good compilers. In part this is a matter of historical accident. Fortran has been around longer than anything else, and companies have invested huge amounts of time and money in making compilers that generate very fast code. It is also a matter of language design, however: Fortran dialects prior to Fortran 90 lacked recursion and pointers, features that greatly complicate the task of generating fast code (at least for programs that can be written in a reasonable fashion without them!). In a similar vein, some languages (e.g., Common Lisp) have been successful in part because they have compilers and supporting tools that do an unusually good job of helping the programmer manage very large projects.<br> 优秀的编译器。 Fortran的成功很大程度上归功于出色的编译器。在某种程度上，这是历史性的事故。 Fortran的存在时间比其他任何公司都长，并且公司已投入大量时间和金钱来制作能够生成非常快速的代码的编译器。但是，这也与语言设计有关：Fortran 90之前的Fortran方言缺少递归和指针，这些功能使生成快速代码的任务大大复杂化（至少对于无需使用它们即可以合理方式编写的程序！）。同样，某些语言（例如Common Lisp）之所以成功，部分原因是它们具有编译器和支持工具，它们在帮助程序员管理大型项目方面做得异常出色。
* Economics, Patronage, and Inertia. Finally, there are factors other than technical merit that greatly influence success. The backing of a powerful sponsor is one. PL/I, at least to first approximation, owed its life to IBM. Cobol and Ada owe their life to the U. S. Department of Defense. C# owes its life to Microsoft. In recent years, Objective-C has enjoyed an enormous surge in popularity as the official language for iPhone and iPad apps. At the other end of the life cycle, some languages remain widely used long after “better” alternatives are available, because of a huge base of installed software and programmer expertise, which would cost too much to replace. Much of the world's financial infrastructure, for example, still functions primarily in Cobol. <br> 经济学，赞助人和惯性。最后，除了技术优势外，还有其他因素会极大地影响成功。一个有力的赞助商的支持就是其中之一。 PL/I，至少是最初的近似，应归功于 IBM。 Cobol和Ada的生命归功于美国国防部。 C#归功于Microsoft。近年来，Objective-C作为iPhone和iPad应用程序的官方语言，受到了极大的欢迎。在生命周期的另一端，某些语言在使用“更好”的替代方法很久之后仍被广泛使用，这是因为已安装的软件和程序员的专业知识基础庞大，而要更换它们会花费太多成本。例如，世界上许多金融基础设施仍主要在Cobol中运作。

Clearly no single factor determines whether a language is "good." As we study programming languages, we shall need to consider issues from several points of view. In particular, we shall need to consider the viewpoints of both the programmer and the language implementor. Sometimes these points of view will be in harmony, as in the desire for execution speed. Often, however, there will be conflicts and tradeoffs, as the conceptual appeal of a feature is balanced against the cost of its implementation. The tradeoff becomes particularly thorny when the implementation imposes costs not only on programs that use the feature, but also on programs that do not.

显然，没有任何一个因素可以确定一种语言是否“好”。在学习编程语言时，我们将需要从多个角度考虑问题。特别是，我们将需要考虑程序员和语言实现者的观点。有时，这些观点会协调一致，就像对执行速度的渴望一样。但是，通常会出现冲突和折衷，因为功能的概念吸引力与实现成本之间是平衡的。当实施不仅在使用该功能的程序上加上成本，而且在不使用该功能的程序上加上成本时，这种权衡变​​得尤为棘手。

In the early days of computing the implementor's viewpoint was predominant. Programming languages evolved as a means of telling a computer what to do. For programmers, however, a language is more aptly defined as a means of expressing algorithms. Just as natural languages constrain exposition and discourse, so programming languages constrain what can and cannot easily be expressed, and have both profound and subtle influence over what the programmer can think. Donald Knuth has suggested that programming be regarded as the art of telling another human being what one wants the computer to do [Knu84].6 This definition perhaps strikes the best sort of compromise. It acknowledges that both conceptual clarity and implementation efficiency are fundamental concerns. This book attempts to capture this spirit of compromise, by simultaneously considering the conceptual and implementation aspects of each of the topics it covers.

在计算的早期，实现者的观点占主导地位。编程语言演变为告诉计算机做什么的一种方式。但是，对于程序员来说，语言被更恰当地定义为表达算法的一种手段。就像自然语言会限制论述和论述一样，编程语言也会限制可以轻松表达的内容，并且对程序员的思考产生深刻而微妙的影响。高德纳（Donald Knuth）建议将编程视为告诉另一个人要计算机做什么的艺术[Knu84]。<sup>6</sup>此定义也许是最好的折衷方案。它承认，概念上的明确性和实施效率都是基本问题。本书试图通过同时考虑其涵盖的每个主题的概念和实现方面来体现这种妥协的精神。

## Design & Implementation

### 1.1 Introduction

Throughout the book, sidebars like this one will highlight the interplay of language design and language implementation. Among other things, we will consider

在本书中，像这样的侧边栏将突出语言设计和语言实现之间的相互作用。除其他事项外，我们将考虑

* Cases (such as those mentioned in this section) in which ease or difficulty of implementation significantly affected the success of a language <br> 案例（例如本节中提到的案例）的实施难易程度严重影响了语言的成功
* Language features that many designers now believe were mistakes, at least in part because of implementation difficulties<br>许多设计师现在认为的语言功能是错误，至少部分是由于实施困难
* Potentially useful features omitted from some languages because of concern that they might be too difficult or slow to implement<br>由于担心它们可能太难或太慢而被某些语言省略了可能有用的功能
* Language features introduced at least in part to facilitate efficient or elegant implementations <br> 至少部分引入了语言功能以促进高效或优雅的实现
* Cases in which a machine architecture makes reasonable features unreasonably expensive<br>机器体系结构使合理的功能变得不合理地昂贵的情况
* Various other tradeoffs in which implementation plays a significant role <br> 在实施过程中起着重要作用的其他各种折衷方案

A complete list of sidebars appears in Appendix B.

侧栏的完整列表显示在附录B中。
